- name: Set facts from env as fallback
  set_fact:
    minecraft_version: "{{ minecraft_version | default(lookup('env','MC_VERSION')) | default('1.20.1', true) }}"
    server_dir: "{{ server_dir | default(lookup('env','MC_SERVER_DIR')) | default('/opt/minecraft', true) }}"
    mods_src: "{{ mods_src | default(lookup('env','MC_MODS')) | default('./mods', true) }}"

- name: Ensure required packages are installed (Debian/Ubuntu)
  apt:
    name: [openjdk-17-jre-headless, screen, curl, unzip, rsync]
    state: present
    update_cache: true
  when: ansible_os_family == 'Debian'

- name: Ensure required packages are installed (RHEL/CentOS)
  yum:
    name: [java-17-openjdk, screen, curl, unzip, rsync]
    state: present
  when: ansible_os_family == 'RedHat'

- name: Create base directories
  file:
    path: "{{ item }}"
    state: directory
    mode: '0755'
  loop:
    - "{{ server_dir }}"
    - "{{ versions_dir }}"

- name: Determine current deployed version (from file if present)
  block:
    - name: Check if current symlink exists
      stat:
        path: "{{ current_link }}"
      register: current_link_stat

    - name: Read current version file
      slurp:
        src: "{{ current_link }}/version.txt"
      register: current_version_raw
      when: current_link_stat.stat.islnk | default(false)
      ignore_errors: true

    - name: Set current_version fact
      set_fact:
        current_version: "{{ (current_version_raw.content | default('') | b64decode | trim) if (current_version_raw is defined and current_version_raw is not failed) else '' }}"

    - name: Decide if version changed
      set_fact:
        version_changed: "{{ current_version | default('') != minecraft_version }}"

- name: Decide if we run full deploy (version change or clean_build)
  set_fact:
    run_full_deploy: "{{ (version_changed | bool) or (clean_build | default(false) | bool) }}"

- name: Deploy new Minecraft version when changed or clean_build
  when: run_full_deploy | bool
  block:
    - name: Stop service if running (ignore if missing)
      systemd:
        name: "{{ service_name }}"
        state: stopped
        no_block: false
      ignore_errors: true
      failed_when: false

    - name: Check if any minecraft processes still running
      shell: |
        pgrep -f "SCREEN -DmS minecraft|java.*-jar server.jar" || true
      register: mc_procs
      changed_when: false
      failed_when: false

    - name: Wait for old process to release world lock
      wait_for:
        path: "{{ version_dir }}/world/session.lock"
        state: absent
        timeout: 30
      when: mc_procs.stdout | trim != ""
      ignore_errors: true

    - name: Force kill lingering screen/java if lock remains
      shell: |
        pgrep -f "SCREEN -DmS minecraft" | xargs -r kill -TERM
        sleep 2
        pgrep -f "SCREEN -DmS minecraft" | xargs -r kill -KILL
        pgrep -f "java.*-jar server.jar" | xargs -r kill -TERM
        sleep 2
        pgrep -f "java.*-jar server.jar" | xargs -r kill -KILL
      when: mc_procs.stdout | trim != ""
      ignore_errors: true

    - name: Remove stale session.lock
      file:
        path: "{{ version_dir }}/world/session.lock"
        state: absent
      ignore_errors: true

    - name: Create version directory structure
      file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ version_dir }}"
        - "{{ version_dir }}/mods"
        - "{{ version_dir }}/logs"

    - name: Fetch version manifest index
      get_url:
        url: https://launchermeta.mojang.com/mc/game/version_manifest.json
        dest: /tmp/version_manifest.json
        mode: '0644'
      when: loader | default('vanilla') == 'vanilla'

    - name: Load version manifest
      slurp:
        src: /tmp/version_manifest.json
      register: manifest_raw
      when: loader | default('vanilla') == 'vanilla'

    - name: Parse manifest JSON
      set_fact:
        manifest: "{{ manifest_raw['content'] | b64decode | from_json }}"
      when: loader | default('vanilla') == 'vanilla'

    - name: Get version URL for specified version
      set_fact:
        version_url: "{{ (manifest.versions | selectattr('id','equalto', minecraft_version) | list | first).url }}"
      when: loader | default('vanilla') == 'vanilla'

    - name: Download version details
      get_url:
        url: "{{ version_url }}"
        dest: /tmp/mc_version.json
        mode: '0644'
      when: loader | default('vanilla') == 'vanilla'

    - name: Load version details
      slurp:
        src: /tmp/mc_version.json
      register: version_raw
      when: loader | default('vanilla') == 'vanilla'

    - name: Parse version JSON
      set_fact:
        version_manifest: "{{ version_raw['content'] | b64decode | from_json }}"
      when: loader | default('vanilla') == 'vanilla'

    - name: Download server.jar for version (vanilla)
      get_url:
        url: "{{ version_manifest.downloads.server.url }}"
        dest: "{{ version_dir }}/server.jar"
        mode: '0755'
      when: loader | default('vanilla') == 'vanilla'

    - name: Ensure Fabric installer URL provided
      fail:
        msg: "Set fabric_installer_url to the Fabric installer .jar URL"
      when: loader == 'fabric' and (fabric_installer_url is not defined or fabric_installer_url | length == 0)

    - name: Install Fabric server
      when: loader == 'fabric'
      block:
        - name: Download Fabric installer
          get_url:
            url: "{{ fabric_installer_url }}"
            dest: "{{ version_dir }}/fabric-installer.jar"
            mode: '0755'
        - name: Run Fabric installer
          command: 
            cmd: "/usr/bin/java -jar fabric-installer.jar server -mcversion {{ minecraft_version }} -downloadMinecraft -dir {{ version_dir }} -noprofile"
            chdir: "{{ version_dir }}"
        - name: Link server.jar to Fabric launcher
          file:
            src: "{{ version_dir }}/fabric-server-launch.jar"
            dest: "{{ version_dir }}/server.jar"
            state: link
            force: true

    - name: Ensure Forge installer URL provided
      fail:
        msg: "Set forge_installer_url to the Forge installer .jar URL"
      when: loader == 'forge' and (forge_installer_url is not defined or forge_installer_url | length == 0)

    - name: Install Forge server
      when: loader == 'forge'
      block:
        - name: Download Forge installer
          get_url:
            url: "{{ forge_installer_url }}"
            dest: "{{ version_dir }}/forge-installer.jar"
            mode: '0755'
        - name: Run Forge installer
          command:
            cmd: "/usr/bin/java -jar forge-installer.jar --installServer"
            chdir: "{{ version_dir }}"
        - name: Find Forge server jar
          find:
            paths: "{{ version_dir }}"
            patterns: "*forge*server*.jar"
            file_type: file
          register: forge_server_jar
        - name: Link server.jar to Forge jar
          file:
            src: "{{ forge_server_jar.files[0].path }}"
            dest: "{{ version_dir }}/server.jar"
            state: link
            force: true
          when: forge_server_jar.matched | default(0) | int > 0

    - name: Ensure NeoForge installer URL provided
      fail:
        msg: "Set neoforge_installer_url to the NeoForge installer .jar URL"
      when: loader == 'neoforge' and (neoforge_installer_url is not defined or neoforge_installer_url | length == 0)

    - name: Install NeoForge server
      when: loader == 'neoforge'
      block:
        - name: Download NeoForge installer
          get_url:
            url: "{{ neoforge_installer_url }}"
            dest: "{{ version_dir }}/neoforge-installer.jar"
            mode: '0755'
        - name: Run NeoForge installer
          command:
            cmd: "/usr/bin/java -jar neoforge-installer.jar --installServer"
            chdir: "{{ version_dir }}"
        - name: Find NeoForge server jar
          find:
            paths: "{{ version_dir }}"
            patterns: "*neoforge*server*.jar"
            file_type: file
          register: neoforge_server_jar
        - name: Link server.jar to NeoForge jar
          file:
            src: "{{ neoforge_server_jar.files[0].path }}"
            dest: "{{ version_dir }}/server.jar"
            state: link
            force: true
          when: neoforge_server_jar.matched | default(0) | int > 0

    - name: Accept EULA for this version
      template:
        src: eula.txt.j2
        dest: "{{ version_dir }}/eula.txt"
        mode: '0644'

    - name: Write version file
      copy:
        dest: "{{ version_dir }}/version.txt"
        content: "{{ minecraft_version }}\n"
        mode: '0644'

    - name: Check local mods_src exists
      stat:
        path: "{{ mods_src }}"
      register: local_mods_stat
      delegate_to: localhost
      become: false

    - name: Sync mods to new version directory
      synchronize:
        src: "{{ mods_src }}/"
        dest: "{{ version_dir }}/mods/"
        delete: true
      become: false
      delegate_to: localhost
      when: mods_src is defined and local_mods_stat.stat.exists and local_mods_stat.stat.isdir

    - name: Create/Update systemd service
      template:
        src: systemd-minecraft.service.j2
        dest: "/etc/systemd/system/{{ service_name }}.service"
        mode: '0644'

    - name: Point current symlink to new version
      file:
        src: "{{ version_dir }}"
        dest: "{{ current_link }}"
        state: link
        force: true

    - name: Reload systemd
      systemd:
        daemon_reload: true

    - name: Ensure service enabled
      systemd:
        name: "{{ service_name }}"
        enabled: true

    - name: Start (or restart) service (non-blocking)
      systemd:
        name: "{{ service_name }}"
        state: restarted
        no_block: true

    - name: Healthcheck - wait for server port
      wait_for:
        host: 127.0.0.1
        port: "{{ server_port }}"
        delay: 5
        timeout: 180

    - name: Healthcheck - wait for log file
      wait_for:
        path: "{{ current_link }}/logs/latest.log"
        state: present
        delay: 1
        timeout: 300

    - name: Grace period before scanning logs
      pause:
        seconds: "{{ post_start_grace }}"

    - name: Healthcheck - check latest logs for errors
      shell: "grep -E -m1 -q 'Exception|ERROR|FATAL' {{ current_link }}/logs/latest.log"
      register: log_errors_new
      failed_when: log_errors_new.rc == 0
      changed_when: false
  rescue:
    - name: Fetch logs to local for debugging
      fetch:
        src: "{{ current_link }}/logs/latest.log"
        dest: "./fetched_logs/latest.log"
        flat: true
      ignore_errors: true

    - name: Fail the play due to startup errors
      fail:
        msg: "Minecraft failed to start or healthcheck failed. Logs fetched to ./fetched_logs/latest.log"

- name: Mods-only path when version unchanged and not clean_build
  when: (not run_full_deploy | bool)
  block:
    - name: Ensure mods directory exists
      file:
        path: "{{ current_link }}/mods"
        state: directory
        mode: '0755'

    - name: Check local mods_src exists (mods-only)
      stat:
        path: "{{ mods_src }}"
      register: local_mods_stat_mods
      delegate_to: localhost
      become: false

    - name: Sync mods to current version
      synchronize:
        src: "{{ mods_src }}/"
        dest: "{{ current_link }}/mods/"
        delete: true
      become: false
      delegate_to: localhost
      register: mods_sync
      when: mods_src is defined and local_mods_stat_mods.stat.exists and local_mods_stat_mods.stat.isdir

    - name: Restart service only if mods changed (non-blocking)
      systemd:
        name: "{{ service_name }}"
        state: restarted
        no_block: true
      when: mods_sync is defined and mods_sync is changed

    - name: Healthcheck after restart (if performed)
      when: mods_sync is defined and mods_sync is changed
      block:
        - name: Wait for port after restart
          wait_for:
            host: 127.0.0.1
            port: "{{ server_port }}"
            delay: 5
            timeout: 120

        - name: Wait for log file after restart
          wait_for:
            path: "{{ current_link }}/logs/latest.log"
            state: present
            delay: 1
            timeout: 300

        - name: Grace period before scanning logs (restart)
          pause:
            seconds: "{{ post_start_grace }}"

        - name: Check logs for errors after restart
          shell: "grep -E -m1 -q 'Exception|ERROR|FATAL' {{ current_link }}/logs/latest.log"
          register: log_errors_restart
          failed_when: log_errors_restart.rc == 0
          changed_when: false
      rescue:
        - name: Fetch logs to local for debugging (mods-only path)
          fetch:
            src: "{{ current_link }}/logs/latest.log"
            dest: "./fetched_logs/latest.log"
            flat: true
          ignore_errors: true

        - name: Fail the play due to restart healthcheck errors
          fail:
            msg: "Minecraft restart failed or healthcheck failed. Logs fetched to ./fetched_logs/latest.log"